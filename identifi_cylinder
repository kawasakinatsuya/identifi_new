#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>

#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>

#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/filter.h>

#include <pcl/kdtree/kdtree.h>
#include <pcl/segmentation/extract_clusters.h>

#include <tf2_ros/buffer.h>
#include <tf2_ros/transform_listener.hpp>
#include <geometry_msgs/msg/transform_stamped.hpp>

#include <deque>
#include <map>
#include <vector>
#include <limits>
#include <algorithm>
#include <cmath>
#include <unordered_set>

#include <Eigen/Dense>

#include <pcl/features/normal_3d.h>
#include <pcl/segmentation/sac_segmentation_from_normals.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/ModelCoefficients.h>


struct Cell
{
  int ix = 0;
  int iy = 0;

  std::vector<int> indices;  // cloud_map 内の点 index
  double min_z = std::numeric_limits<double>::infinity();
  double z_max = -std::numeric_limits<double>::infinity();

  // --- ground plane (地面点のみ) ---
  std::vector<int> ground_indices;
  Eigen::Vector3f n_ground = Eigen::Vector3f(0,0,1);
  float d_ground = 0.0f;
  bool has_ground_plane = false;

  // --- non-ground plane (非地面点のみ) ---
  std::vector<int> nonground_indices;
  Eigen::Vector3f n_ng = Eigen::Vector3f(0,0,1);
  float d_ng = 0.0f;
  bool has_ng_plane = false;

  // --- cell classification flags ---
  bool ground = false; // 平地（緑）
  bool slope  = false; // 斜面（シアン）
  bool small_obs   = false; // 乗り越え可（黄）
  bool big_obs  = false; // 乗り越え不可（赤）
  bool unknown = false;

  bool trunk = false;
};

struct TimeCloud
{
  rclcpp::Time stamp;
  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_world;
};

// -------------------- math helpers --------------------
static inline double rad2deg(double rad)
{
  return rad * 180.0 / 3.14159265358979323846;
}

static inline double angle_deg(const Eigen::Vector3f& a, const Eigen::Vector3f& b)
{
  double c = (double)a.dot(b);
  c = std::max(-1.0, std::min(1.0, c));
  return rad2deg(std::acos(c));
}

// 平面 n.x*x + n.y*y + n.z*z + d = 0 から z を求める
static inline bool plane_z_at_xy(const Eigen::Vector3f& n, float d, float x, float y, float& z_out)
{
  if(std::abs(n.z()) < 1e-6f) return false;
  z_out = -(n.x()*x + n.y()*y + d) / n.z();
  return std::isfinite(z_out);
}

// PCAで平面を当てて法線を求める
static inline bool fit_plane_pca(
  const pcl::PointCloud<pcl::PointXYZ>& cloud,
  const std::vector<int>& indices,
  Eigen::Vector3f& n_out,
  float& d_out)
{
  if ((int)indices.size() < 10) return false;

  Eigen::Vector3f mean(0,0,0);
  int cnt = 0;
  for(int idx : indices){
    const auto& p = cloud.points[idx];
    if(!std::isfinite(p.x) || !std::isfinite(p.y) || !std::isfinite(p.z)) continue;
    mean += Eigen::Vector3f(p.x, p.y, p.z);
    cnt++;
  }
  if(cnt < 10) return false;
  mean /= (float)cnt;

  Eigen::Matrix3f cov = Eigen::Matrix3f::Zero();
  for(int idx : indices){
    const auto& p = cloud.points[idx];
    if(!std::isfinite(p.x) || !std::isfinite(p.y) || !std::isfinite(p.z)) continue;
    Eigen::Vector3f q(p.x, p.y, p.z);
    Eigen::Vector3f d = q - mean;
    cov += d * d.transpose();
  }
  cov /= (float)cnt;

  Eigen::SelfAdjointEigenSolver<Eigen::Matrix3f> es(cov);
  if(es.info() != Eigen::Success) return false;

  // 最小固有値の固有ベクトルが法線
  Eigen::Vector3f n = es.eigenvectors().col(0);
  n.normalize();

  // 上向きに揃える
  if(n.z() < 0) n = -n;

  n_out = n;
  d_out = -n.dot(mean);
  return true;
}

// -------------------- Node --------------------
class IdentificationNode : public rclcpp::Node
{
public:
  IdentificationNode()
  : Node("Identification_node"), tf_buffer_(this->get_clock()), tf_listener_(tf_buffer_)
  {
    sub_ = this->create_subscription<sensor_msgs::msg::PointCloud2>(
      "/cloud_registered", rclcpp::SensorDataQoS(),
      std::bind(&IdentificationNode::cloud_callback, this, std::placeholders::_1));

    pub_colored_   = this->create_publisher<sensor_msgs::msg::PointCloud2>("/identification/colored", 10);
    pub_ground_    = this->create_publisher<sensor_msgs::msg::PointCloud2>("/ground_cluster/ground", 10);
    pub_nonground_ = this->create_publisher<sensor_msgs::msg::PointCloud2>("/ground_cluster/nonground", 10);

    // frames
    this->declare_parameter("world_frame", "camera_init");
    this->declare_parameter("base_frame",  "body");

    // map build
    this->declare_parameter("voxel_size", 0.05);
    this->declare_parameter("time_window", 10.0);

    // grid
    this->declare_parameter("cell_size", 0.20);
    this->declare_parameter("min_points_per_cell", 10);

    // Step1: “最下点 + 帯域”
    this->declare_parameter("ground_band", 0.10);

    // Step2: clustering parameters
    this->declare_parameter("cluster_tolerance", 0.20);
    this->declare_parameter("min_cluster_size", 200);
    this->declare_parameter("max_cluster_size", 200000);

    this->declare_parameter("extra_ground_z_margin", 0.05);
    this->declare_parameter("extra_ground_size_ratio", 0.10);

    // ---- 追加：識別条件 ----
    this->declare_parameter("flat_deg_max", 5.0);        // 平地とみなす最大角度
    this->declare_parameter("slope_deg_max", 30.0);      // 斜面とみなす最大角度
    this->declare_parameter("step_h_max", 0.15);         // 15cm
    this->declare_parameter("ref_search_radius", 1.0);   // [m] 近傍地面探索半径（ルール1用）
    this->declare_parameter("flat_ref_deg_max", 10.0);   // 近傍基準地面として使える傾き（<=10deg）

    this->declare_parameter("trunk_enable", true);
    this->declare_parameter("trunk_roi_radius", 0.35); 
    this->declare_parameter("trunk_roi_z_min", -1.0);
    this->declare_parameter("trunk_roi_z_max",  1.0);
    this->declare_parameter("trunk_min_roi_points", 80);
    this->declare_parameter("trunk_normal_k", 20); 
    this->declare_parameter("trunk_dist_thresh", 0.05);
    this->declare_parameter("trunk_radius_min", 0.03);
    this->declare_parameter("trunk_radius_max", 0.25);
    this->declare_parameter("trunk_min_inliers", 60);
    this->declare_parameter("trunk_max_cells_per_frame", 60);

    RCLCPP_INFO(this->get_logger(), "IdentificationNode initialized (min-z per cell + largest cluster + cell bool classification).");
  }

private:
  // ---- callback ----
  void cloud_callback(const sensor_msgs::msg::PointCloud2::SharedPtr msg)
  {
    const std::string world_frame = this->get_parameter("world_frame").as_string();
    const std::string base_frame  = this->get_parameter("base_frame").as_string();

    // msg -> pcl
    pcl::PointCloud<pcl::PointXYZ>::Ptr input(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::fromROSMsg(*msg, *input);

    // remove NaN
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);
    std::vector<int> nan_indices;
    pcl::removeNaNFromPointCloud(*input, *cloud_filtered, nan_indices);

    const rclcpp::Time stamp(msg->header.stamp);

    // TF lookup (world <- base)
    geometry_msgs::msg::TransformStamped tf_w_b;
    try{
      tf_w_b = tf_buffer_.lookupTransform(world_frame, base_frame, stamp);
    }catch(const std::exception &e){
      RCLCPP_WARN(this->get_logger(), "TF lookup failed (%s -> %s): %s", base_frame.c_str(), world_frame.c_str(), e.what());
      return;
    }

    const double bx = tf_w_b.transform.translation.x;
    const double by = tf_w_b.transform.translation.y;

    // downsample current frame
    const double voxel_size = this->get_parameter("voxel_size").as_double();
    pcl::PointCloud<pcl::PointXYZ>::Ptr down = voxel_downsample(cloud_filtered, voxel_size);

    // push to buffer
    TimeCloud tc;
    tc.stamp = stamp;
    tc.cloud_world = down;
    cloud_buffer_.push_back(tc);

    // pop old
    const double time_window = this->get_parameter("time_window").as_double();
    pop_old_clouds(stamp, time_window);

    // build merged map and downsample again
    pcl::PointCloud<pcl::PointXYZ>::Ptr merged = build_map();
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_map = voxel_downsample(merged, voxel_size);

    // Step1: build grid and min_z per cell
    const double cell_size = this->get_parameter("cell_size").as_double();
    const int min_pts_cell = this->get_parameter("min_points_per_cell").as_int();

    std::map<std::pair<int,int>, Cell> cells;
    build_grid_and_minz(*cloud_map, cells, bx, by, cell_size);

    // collect ground-candidate indices (min_z + band)
    const double ground_band = this->get_parameter("ground_band").as_double();
    std::vector<int> candidate_indices;
    candidate_indices.reserve(cloud_map->points.size() / 4);

    for(const auto& kv : cells){
      const Cell& c = kv.second;
      if((int)c.indices.size() < min_pts_cell) continue;
      if(!std::isfinite(c.min_z)) continue;

      const double z_thr = c.min_z + ground_band;

      for(int idx : c.indices){
        const auto& pt = cloud_map->points[idx];
        if(!std::isfinite(pt.z)) continue;
        if((double)pt.z <= z_thr){
          candidate_indices.push_back(idx);
        }
      }
    }

    if(candidate_indices.size() < 100){
      publish_all_nonground(*msg, cloud_map);
      return;
    }

    // unique
    std::sort(candidate_indices.begin(), candidate_indices.end());
    candidate_indices.erase(std::unique(candidate_indices.begin(), candidate_indices.end()), candidate_indices.end());

    // build candidate cloud
    pcl::PointCloud<pcl::PointXYZ>::Ptr cand_cloud(new pcl::PointCloud<pcl::PointXYZ>);
    cand_cloud->points.reserve(candidate_indices.size());

    // map: cand_cloud index -> original index
    std::vector<int> cand_to_orig;
    cand_to_orig.reserve(candidate_indices.size());

    for(int orig_idx : candidate_indices){
      cand_cloud->points.push_back(cloud_map->points[orig_idx]);
      cand_to_orig.push_back(orig_idx);
    }
    cand_cloud->width = (uint32_t)cand_cloud->points.size();
    cand_cloud->height = 1;

    // Step2: Euclidean clustering on candidate points
    std::vector<pcl::PointIndices> cluster_indices;
    euclidean_cluster(cand_cloud, cluster_indices);

    if(cluster_indices.empty()){
      publish_all_nonground(*msg, cloud_map);
      return;
    }

    // pick largest cluster
    int best_k = -1;
    size_t best_size = 0;
    for(int k = 0; k < (int)cluster_indices.size(); ++k){
      size_t sz = cluster_indices[k].indices.size();
      if(sz > best_size){
        best_size = sz;
        best_k = k;
      }
    }

    if(best_k < 0 || best_size < 50){
      publish_all_nonground(*msg, cloud_map);
      return;
    }

    const double z_margin  = this->get_parameter("extra_ground_z_margin").as_double();
    const double ratio_min = this->get_parameter("extra_ground_size_ratio").as_double();

    double best_min_z = cluster_min_z(cand_cloud, cluster_indices, best_k);
    if(!std::isfinite(best_min_z)){
      publish_all_nonground(*msg, cloud_map);
      return;
    }

    std::vector<int> ground_cluster_ids;
    ground_cluster_ids.push_back(best_k);
    const size_t best_sz = cluster_indices[best_k].indices.size();

    for(int k = 0; k < (int)cluster_indices.size(); ++k){
      if(k == best_k) continue;
      const size_t sz = cluster_indices[k].indices.size();
      if(sz < (size_t)std::ceil((double)best_sz * ratio_min)) continue;
      double mz = cluster_min_z(cand_cloud, cluster_indices, k);
      if(!std::isfinite(mz)) continue;
      if(mz <= best_min_z + z_margin){
        ground_cluster_ids.push_back(k);
      }
    }

    // build ground mask (original indices)
    std::unordered_set<int> ground_set;
    ground_set.reserve(best_size * 2);
    for(int cid : ground_cluster_ids){
      for(int cand_idx : cluster_indices[cid].indices){
        int orig_idx = cand_to_orig[cand_idx];
        ground_set.insert(orig_idx);
      }
    }

    // 1) 各セルに ground_indices / nonground_indices を入れて平面推定
    for(auto& kv : cells){
      Cell& c = kv.second;

      c.ground_indices.clear();
      c.nonground_indices.clear();
      c.has_ground_plane = false;
      c.has_ng_plane = false;

      c.ground = false;
      c.slope  = false;
      c.small_obs   = false;
      c.big_obs  = false;
      c.unknown = false;

      for(int idx : c.indices){
        if(ground_set.find(idx) != ground_set.end()){
          c.ground_indices.push_back(idx);
        }else{
          c.nonground_indices.push_back(idx);
        }
      }

      // 地面平面（地面クラスタ由来）
      if((int)c.ground_indices.size() >= min_pts_cell){
        Eigen::Vector3f n;
        float d;
        if(fit_plane_pca(*cloud_map, c.ground_indices, n, d)){
          c.n_ground = n;
          c.d_ground = d;
          c.has_ground_plane = true;
        }
      }

      // 非地面平面
      if((int)c.nonground_indices.size() >= min_pts_cell){
        Eigen::Vector3f n;
        float d;
        if(fit_plane_pca(*cloud_map, c.nonground_indices, n, d)){
          c.n_ng = n;
          c.d_ng = d;
          c.has_ng_plane = true;
        }
      }
    }

    // ---- cell classification params ----
    const double flat_deg_max     = this->get_parameter("flat_deg_max").as_double();       // 緑
    const double slope_deg_max    = this->get_parameter("slope_deg_max").as_double();      // シアン
    const double step_h_max       = this->get_parameter("step_h_max").as_double();         // 黄/赤
    const double ref_R            = this->get_parameter("ref_search_radius").as_double();
    const double flat_ref_deg_max = this->get_parameter("flat_ref_deg_max").as_double();   // 参照地面の傾き

    const int ref_range = std::max(1, (int)std::ceil(ref_R / cell_size));
    Eigen::Vector3f z_axis(0,0,1);

    // 2) 近傍地面に対して角度差・高さ差で分類
    for(auto& kv : cells){
      Cell& c = kv.second;

      c.ground = false;
      c.slope  = false;
      c.small_obs   = false;
      c.big_obs  = false;
      c.unknown = false;

      // --- セル表面平面（ここが "地面クラスタ内の斜面" に効く） ---
      bool has_plane = false;
      Eigen::Vector3f n_cell = z_axis;

      // ng_plane があるならそれを優先（地面クラスタ内でも傾きを拾える）
      if(c.has_ng_plane){
        n_cell = c.n_ng;
        has_plane = true;
      }else if(c.has_ground_plane){
        n_cell = c.n_ground;
        has_plane = true;
      }

      if(!has_plane){
        c.unknown = true;
        continue;
      }

      const double z_range = c.z_max - c.min_z;
      const bool tall_object_like = std::isfinite(z_range) && (z_range > step_h_max * 1.2);
      const double tilt = angle_deg(n_cell, z_axis);
      if(!tall_object_like){
        if(tilt <= flat_deg_max){
          c.ground = true;
          continue;
        }
        if(tilt <= slope_deg_max){
          c.slope = true;
          continue;
        }
      }

      // --- 近傍の基準地面平面を探す ---
      bool found_ref = false;
      Eigen::Vector3f n_ref = z_axis;
      float d_ref = 0.0f;
      float best_dist = std::numeric_limits<float>::infinity();

      // セル中心座標（world）
      float xc = (float)(bx + (c.ix + 0.5) * cell_size);
      float yc = (float)(by + (c.iy + 0.5) * cell_size);

      for(int dy=-ref_range; dy<=ref_range; ++dy){
        for(int dx=-ref_range; dx<=ref_range; ++dx){
          auto it = cells.find({c.ix + dx, c.iy + dy});
          if(it == cells.end()) continue;

          const Cell& nb = it->second;
          if(!nb.has_ground_plane) continue;

          double dist = std::sqrt((double)(dx*dx + dy*dy)) * cell_size;
          if(dist > ref_R) continue;

          // “水平に近い ground_plane のみ”基準として採用
          double tilt = angle_deg(nb.n_ground, z_axis);
          if(tilt > flat_ref_deg_max) continue;

          if((float)dist < best_dist){
            best_dist = (float)dist;
            n_ref = nb.n_ground;
            d_ref = nb.d_ground;
            found_ref = true;
          }
        }
      }

      // 見つからなければ鉛直基準（角度差中心で分類）
      if(!found_ref){
        n_ref = z_axis;
        d_ref = 0.0f;
      }

      float z_ref = 0.f;
      bool ok_ref = plane_z_at_xy(n_ref, d_ref, xc, yc, z_ref);

      double dz = 999.0;
      if(ok_ref){
        if(std::isfinite(c.z_max)){
          dz = std::abs((double)c.z_max - (double)z_ref);
        }else if(std::isfinite(c.min_z)){
          dz = std::abs((double)c.min_z - (double)z_ref);
        }
      }
      if(dz <= step_h_max){
        c.small_obs = true;
      }else{
        c.big_obs = true;
      }
    }

    const bool trunk_enable = this->get_parameter("trunk_enable").as_bool();
    if(trunk_enable){
      const double roi_R = this->get_parameter("trunk_roi_radius").as_double();
      const double roi_zmin = this->get_parameter("trunk_roi_z_min").as_double();
      const double roi_zmax = this->get_parameter("trunk_roi_z_max").as_double();
      const int min_roi_pts = this->get_parameter("trunk_min_roi_points").as_int();
      const int normal_k = this->get_parameter("trunk_normal_k").as_int();
      const double dist_th = this->get_parameter("trunk_dist_thresh").as_double();
      const double r_min = this->get_parameter("trunk_radius_min").as_double();
      const double r_max = this->get_parameter("trunk_radius_max").as_double();
      const int min_inliers   = this->get_parameter("trunk_min_inliers").as_int();
      const int max_cells     = this->get_parameter("trunk_max_cells_per_frame").as_int();
      pcl::search::KdTree<pcl::PointXYZ>::Ptr kdtree(new pcl::search::KdTree<pcl::PointXYZ>);
      kdtree->setInputCloud(cloud_map);
      int processed = 0;
      int detected  = 0;
      for(auto& kv : cells){
        if(processed >= max_cells) break;
        Cell& c = kv.second;
        c.trunk = false;
        if(!(c.big_obs || c.small_obs)) continue;
        float xc = (float)(bx + (c.ix + 0.5) * cell_size);
        float yc = (float)(by + (c.iy + 0.5) * cell_size);
        processed++;
        bool ok = detect_cylinder_in_roi(cloud_map, kdtree, xc, yc, (float)roi_R, (float)roi_zmin, (float)roi_zmax, min_roi_pts, normal_k, (float)dist_th, (float)r_min, (float)r_max, min_inliers);
        if(ok){
          detected++;
          c.trunk = true;
        }
      }
    }

    // -------- publish clouds --------
    pcl::PointCloud<pcl::PointXYZ>::Ptr ground(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::PointCloud<pcl::PointXYZ>::Ptr nonground(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr colored(new pcl::PointCloud<pcl::PointXYZRGB>);

    ground->points.reserve(cloud_map->points.size());
    nonground->points.reserve(cloud_map->points.size());
    colored->points.reserve(cloud_map->points.size());

    auto cell_key_of_point = [&](const pcl::PointXYZ& pt)->std::pair<int,int>{
      double xl = (double)pt.x - bx;
      double yl = (double)pt.y - by;
      int ix = (int)std::floor(xl / cell_size);
      int iy = (int)std::floor(yl / cell_size);
      return {ix, iy};
    };

    for(int i = 0; i < (int)cloud_map->points.size(); ++i){
      const auto& pt = cloud_map->points[i];

      pcl::PointXYZRGB prgb;
      prgb.x = pt.x; prgb.y = pt.y; prgb.z = pt.z;

      auto key = cell_key_of_point(pt);
      auto it  = cells.find(key);

      if(it != cells.end()){
        const Cell& c = it->second;
      }

      if(c.ground){
        // ground = green
        prgb.r = 0; prgb.g = 255; prgb.b = 0;
        ground->points.push_back(pt);
      }else{
        if(c.trunk){
          //pink
          prgb.r = 255; prgb.g = 153; prgb.b = 153;
        }
        if(c.slope){
          // slope = cyan
          prgb.r = 0; prgb.g = 255; prgb.b = 255;
        }else if(c.small_obs){
          // traversable obstacle = yellow
          prgb.r = 255; prgb.g = 255; prgb.b = 0;
        }else if(c.big_obs){
          // blocked obstacle = red
          prgb.r = 255; prgb.g = 0; prgb.b = 0;
        }else{
          //purple
          prgb.r = 255; prgb.g = 0; prgb.b = 255;
        }
        nonground->points.push_back(pt);
      }

      colored->points.push_back(prgb);
    }



    finalize_cloud(ground);
    finalize_cloud(nonground);
    finalize_cloud(colored);

    sensor_msgs::msg::PointCloud2 msg_col, msg_g, msg_ng;
    pcl::toROSMsg(*colored, msg_col);
    pcl::toROSMsg(*ground, msg_g);
    pcl::toROSMsg(*nonground, msg_ng);

    msg_col.header = msg->header;
    msg_g.header   = msg->header;
    msg_ng.header  = msg->header;

    pub_colored_->publish(msg_col);
    pub_ground_->publish(msg_g);
    pub_nonground_->publish(msg_ng);

    RCLCPP_INFO_THROTTLE(this->get_logger(), *this->get_clock(), 1000,
      "map=%zu cand=%zu clusters=%zu ground_set=%zu out_ground=%zu",
      cloud_map->points.size(),
      cand_cloud->points.size(),
      cluster_indices.size(),
      ground_set.size(),
      ground->points.size());
  }

  // ---- helpers ----
  pcl::PointCloud<pcl::PointXYZ>::Ptr voxel_downsample(const pcl::PointCloud<pcl::PointXYZ>::Ptr& input, double vx)
  {
    pcl::VoxelGrid<pcl::PointXYZ> voxel;
    voxel.setInputCloud(input);
    voxel.setLeafSize((float)vx, (float)vx, (float)vx);

    pcl::PointCloud<pcl::PointXYZ>::Ptr out(new pcl::PointCloud<pcl::PointXYZ>);
    voxel.filter(*out);
    return out;
  }

  void pop_old_clouds(const rclcpp::Time& now, double time_window)
  {
    while(!cloud_buffer_.empty()){
      double dt = (now - cloud_buffer_.front().stamp).seconds();
      if(dt <= time_window) break;
      cloud_buffer_.pop_front();
    }
  }

  pcl::PointCloud<pcl::PointXYZ>::Ptr build_map()
  {
    pcl::PointCloud<pcl::PointXYZ>::Ptr merged(new pcl::PointCloud<pcl::PointXYZ>);
    for(const auto& c : cloud_buffer_){
      *merged += *(c.cloud_world);
    }
    return merged;
  }

  void build_grid_and_minz(const pcl::PointCloud<pcl::PointXYZ>& cloud,
                           std::map<std::pair<int,int>, Cell>& cells,
                           double bx, double by, double cell_size)
  {
    cells.clear();

    for(int i = 0; i < (int)cloud.points.size(); ++i){
      const auto& pt = cloud.points[i];
      if(!std::isfinite(pt.x) || !std::isfinite(pt.y) || !std::isfinite(pt.z)) continue;

      double xl = (double)pt.x - bx;
      double yl = (double)pt.y - by;

      int ix = (int)std::floor(xl / cell_size);
      int iy = (int)std::floor(yl / cell_size);

      Cell& c = cells[{ix, iy}];
      c.ix = ix;
      c.iy = iy;
      c.indices.push_back(i);

      if((double)pt.z < c.min_z) c.min_z = (double)pt.z;
      if((double)pt.z > c.z_max) c.z_max = (double)pt.z;
    }
  }

  void euclidean_cluster(const pcl::PointCloud<pcl::PointXYZ>::Ptr& cloud,
                         std::vector<pcl::PointIndices>& cluster_indices)
  {
    cluster_indices.clear();

    const double tol = this->get_parameter("cluster_tolerance").as_double();
    const int min_sz = this->get_parameter("min_cluster_size").as_int();
    const int max_sz = this->get_parameter("max_cluster_size").as_int();

    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);
    tree->setInputCloud(cloud);

    pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;
    ec.setClusterTolerance(tol);
    ec.setMinClusterSize(min_sz);
    ec.setMaxClusterSize(max_sz);
    ec.setSearchMethod(tree);
    ec.setInputCloud(cloud);
    ec.extract(cluster_indices);
  }

  template<typename CloudPtrT>
  void finalize_cloud(CloudPtrT& cloud)
  {
    cloud->width = (uint32_t)cloud->points.size();
    cloud->height = 1;
    cloud->is_dense = true;
  }

  void publish_all_nonground(const sensor_msgs::msg::PointCloud2& in_msg,
                            const pcl::PointCloud<pcl::PointXYZ>::Ptr& cloud)
  {
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr colored(new pcl::PointCloud<pcl::PointXYZRGB>);
    colored->points.reserve(cloud->points.size());

    for(const auto& pt : cloud->points){
      pcl::PointXYZRGB prgb;
      prgb.x = pt.x; prgb.y = pt.y; prgb.z = pt.z;
      prgb.r = 255; prgb.g = 0; prgb.b = 0;
      colored->points.push_back(prgb);
    }
    finalize_cloud(colored);

    sensor_msgs::msg::PointCloud2 msg_col;
    pcl::toROSMsg(*colored, msg_col);
    msg_col.header = in_msg.header;
    pub_colored_->publish(msg_col);

    sensor_msgs::msg::PointCloud2 msg_ng;
    pcl::toROSMsg(*cloud, msg_ng);
    msg_ng.header = in_msg.header;
    pub_nonground_->publish(msg_ng);
  }

  double cluster_min_z(const pcl::PointCloud<pcl::PointXYZ>::Ptr& cand_cloud,
                       const std::vector<pcl::PointIndices>& cluster_indices,
                       int k)
  {
    double mz = std::numeric_limits<double>::infinity();
    for(int cand_idx : cluster_indices[k].indices){
      const auto& p = cand_cloud->points[cand_idx];
      if(!std::isfinite(p.z)) continue;
      if((double)p.z < mz) mz = (double)p.z;
    }
    if(!std::isfinite(mz)){
      return std::numeric_limits<double>::quiet_NaN();
    }
    return mz;
  }

  bool detect_cylinder_in_roi(const pcl::PointCloud<pcl::PointXYZ>::Ptr& cloud_map, pcl::search::KdTree<pcl::PointXYZ>::Ptr& kdtree, float xc, float yc, float roi_radius, float zmin, float zmax, int min_roi_pts, int normal_k, float dist_thresh, float radius_min, float radius_max, int min_inliers)
  {
    pcl::PointXYZ query;
    query.x = xc; query.y = yc; query.z = 0.0f;
    std::vector<int> idx;
    std::vector<float> dist2;
    if(kdtree->radiusSearch(query, roi_radius, idx, dist2) <= 0){
      return false;
    }
    pcl::PointCloud<pcl::PointXYZ>::Ptr roi(new pcl::PointCloud<pcl::PointXYZ>);
    roi->points.reserve(idx.size());

    for(int i : idx){
      const auto& p = cloud_map->points[i];
      if(!std::isfinite(p.x) || !std::isfinite(p.y) || !std::isfinite(p.z)) continue;
      if(p.z < zmin || p.z > zmax) continue;
      roi->points.push_back(p);
    }
    roi->width = (uint32_t)roi->points.size();
    roi->height = 1;
    roi->is_dense = true;
    if((int)roi->points.size() < min_roi_pts){
      return false;
    }
    pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> ne;
    ne.setInputCloud(roi);
    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree_roi(new pcl::search::KdTree<pcl::PointXYZ>);
    ne.setSearchMethod(tree_roi);
    ne.setKSearch(normal_k);
    pcl::PointCloud<pcl::Normal>::Ptr normals(new pcl::PointCloud<pcl::Normal>);
    ne.compute(*normals);

    pcl::SACSegmentationFromNormals<pcl::PointXYZ, pcl::Normal> seg;
    seg.setOptimizeCoefficients(true);
    seg.setModelType(pcl::SACMODEL_CYLINDER);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setNormalDistanceWeight(0.1);
    seg.setMaxIterations(200);
    seg.setDistanceThreshold(dist_thresh);
    seg.setRadiusLimits(radius_min, radius_max);
    seg.setInputCloud(roi);
    seg.setInputNormals(normals);
    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
    pcl::ModelCoefficients::Ptr coeff(new pcl::ModelCoefficients);
    seg.segment(*inliers, *coeff);
    if(inliers->indices.empty()) return false;
    if((int)inliers->indices.size() < min_inliers) return false;
    return true;
  }

private:
  rclcpp::Subscription<sensor_msgs::msg::PointCloud2>::SharedPtr sub_;

  rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr pub_colored_;
  rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr pub_ground_;
  rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr pub_nonground_;

  tf2_ros::Buffer tf_buffer_;
  tf2_ros::TransformListener tf_listener_;

  std::deque<TimeCloud> cloud_buffer_;
};

int main(int argc, char** argv)
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<IdentificationNode>());
  rclcpp::shutdown();
  return 0;
}
